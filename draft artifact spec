# This draft will not be used at all. I'll expand on the roadmap in the Architect Issues ASAP

```
Automaton = {
  Artifact = {
    -- build instruction
    -- image location
    -- version control system (e.g. git)
  }
}
```

The Artifact Specification defines a set of components that will be utilised to
perform the service that one automaton will provide. This includes the
underlying filesystem (the *image*), *source code*, *pre-hook* and *post-hooks* of the
automaton, and the *deployment procedure* that the automaton should go through
before being with the rest of the system.

The image of the automaton should be included via a content address, it is essentially
a representation of a filesystem consisting of all the run time dependencies of
one automaton, and will become the immutable base filesystem of the automaton once it is initiated.
The image address could be either obtained from an external node (for example docker registry)
or cached locally. The Architect daemon has the responsibility to resolve and utilise this address
and make sure the image is not downloaded twice.
When an automaton is deployed, the image will become the immutable filesystem,
possibly overlaid by a writable layer as defined in the state specification.

```4
Automaton = {
  Artifact = {
    image = "ubuntu@sha256:abc1234..."
  }
```

In the above example, I have used the docker's semantics of specifying the container image address.
However when implementing the actual language, this could be an URL and hash tuple, an IPFS address,
or it could even be a link to a Dockerfile/shell.nix.

For the source code, pre-hook and post-hook for building the automaton, I have not yet
came up with a semantic way of declaring this in Architect language, but it would probably
be similar to

For the deployment procedure, at a current stage we will be using CI/CD systems to
automate the running of a particular automaton.
