# Dockertools

- [Dockertools Nix source code](https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/default.nix)
- [Cheap Docker Images with Nix by lethalman](http://lethalman.blogspot.com/2016/04/cheap-docker-images-with-nix_15.html)
- [Dockertools Tutorial in Nix Manual](https://nixos.org/nixpkgs/manual/#sec-pkgs-dockerTools)


So using lethalman's example, I built a docker image with:
```nix
# ./redis.nix
{ pkgs ? import <nixpkgs> {} }:

with pkgs;
let
	entrypoint = writeScript "entrypoint.sh" ''
		#!${stdenv.shell}
		set -e
    exec "$@"
	'';
in
dockerTools.buildImage {
	name = "redis";
	tag = "latest";

	fromImage = null;
	fromImageName = null;
	fromImageTag = "latest";

	contents = [ redis ];
	runAsRoot = ''
		#!${stdenv.shell}
		mkdir -p /data
	'';

	config = {
		Cmd = [ "redis-server" ];
		Entrypoint = [ entrypoint ];
		WorkingDir = "/data";
		Volumes = {
			"/data" = {};
		};
	};
}
```

This is the derivation expression to build a redis docker image. Now if we run `nix-instantiate redis.nix` and obtain the derivation `/nix/store/3w0rb8j1nfxi1bbjs7191gpv2jn6rz7k-docker-image-redis.tar.gz.drv`

View the derivation in json format using `nix show-derivation /nix/store/3w0rb8j1nfxi1bbjs7191gpv2jn6rz7k-docker-image-redis.tar.gz.drv`.
```json
// /nix/store/3w0rb8j1nfxi1bbjs7191gpv2jn6rz7k-docker-image-redis.tar.gz.drv
{
  "/nix/store/3w0rb8j1nfxi1bbjs7191gpv2jn6rz7k-docker-image-redis.tar.gz.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/al50if29nr4a3ivxj2b92412s0q6qria-docker-image-redis.tar.gz"
      }
    },
    "inputSrcs": [
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/795qvajr0gpi0lsyimb0hd59k1in8k64-jq-1.5.drv": [
        "out"
      ],
      "/nix/store/cl2fm834c79y7k8iyajj8wp9fdzvbkm1-redis-config.json.drv": [
        "out"
      ],
      "/nix/store/kp5zb1210ys586k078iz4qmpjflqkrd5-coreutils-8.29.drv": [
        "out"
      ],
      "/nix/store/magw9l8nylfknv0qxgz7pgklpjsribws-findutils-4.6.0.drv": [
        "out"
      ],
      "/nix/store/mg74pfbm26rqcd8l3s7hqj92v51g3lja-runtime-deps.drv": [
        "out"
      ],
      "/nix/store/n5x7bhcb8phfnvhcg3kh14b5j9241hm8-docker-layer-redis.drv": [
        "out"
      ],
      "/nix/store/qf3gpwdgymmfbai9d9d71spc2x96hx3y-stdenv.drv": [
        "out"
      ],
      "/nix/store/qkf7yna7x4nvjscxm84fzkf0xx9svcy3-bash-4.4-p12.drv": [
        "out"
      ],
      "/nix/store/xkvi9a3gjrq5p0xsp5mjh3xhnzll6gzq-jshon-20140712.drv": [
        "out"
      ],
      "/nix/store/xpybv6ps7vyav5x08pn9hb56lxjplyny-pigz-2.3.4.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/zqh3l3lyw32q1ayb15bnvg9f24j5v2p0-bash-4.4-p12/bin/bash",
    "args": [
      "-e",
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "env": {
      "baseJson": "/nix/store/kxv45zmi3zrdxlgsp8fk9hsmrnbncaq8-redis-config.json",
      "buildCommand": "# Print tar contents:\n# 1: Interpreted as relative to the root directory\n# 2: With no trailing slashes on directories\n# This is useful for ensuring that the output matches the\n# values generated by the \"find\" command\nls_tar() {\n  for f in $(tar -tf $1 | xargs realpath -ms --relative-to=.); do\n    if [[ \"$f\" != \".\" ]]; then\n      echo \"/$f\"\n    fi\n  done\n}\n\nmkdir image\ntouch baseFiles\nif [[ -n \"$fromImage\" ]]; then\n  echo \"Unpacking base image...\"\n  tar -C image -xpf \"$fromImage\"\n  # Do not import the base image configuration and manifest\n  chmod a+w image image/*.json\n  rm -f image/*.json\n\n  if [[ -z \"$fromImageName\" ]]; then\n    fromImageName=$(jshon -k < image/repositories|head -n1)\n  fi\n  if [[ -z \"$fromImageTag\" ]]; then\n    fromImageTag=$(jshon -e $fromImageName -k \\\n                   < image/repositories|head -n1)\n  fi\n  parentID=$(jshon -e $fromImageName -e $fromImageTag -u \\\n             < image/repositories)\n\n  for l in image/*/layer.tar; do\n    ls_tar $l >> baseFiles\n  done\nfi\n\nchmod -R ug+rw image\n\nmkdir temp\ncp /nix/store/2yp7s50mvcssm44v69rmczf0pcllmmll-docker-layer-redis/* temp/\nchmod ug+w temp/*\n\nfor dep in $(cat $layerClosure); do\n  find $dep >> layerFiles\ndone\n\necho \"Adding layer...\"\n# Record the contents of the tarball with ls_tar.\nls_tar temp/layer.tar >> baseFiles\n\n# Append nix/store directory to the layer so that when the layer is loaded in the\n# image /nix/store has read permissions for non-root users.\n# nix/store is added only if the layer has /nix/store paths in it.\nif [ $(wc -l < $layerClosure) -gt 1 ] && [ $(grep -c -e \"^/nix/store$\" baseFiles) -eq 0 ]; then\n  mkdir -p nix/store\n  chmod -R 555 nix\n  echo \"./nix\" >> layerFiles\n  echo \"./nix/store\" >> layerFiles\nfi\n\n# Get the files in the new layer which were *not* present in\n# the old layer, and record them as newFiles.\ncomm <(sort -n baseFiles|uniq) \\\n     <(sort -n layerFiles|uniq|grep -v /nix/store/2yp7s50mvcssm44v69rmczf0pcllmmll-docker-layer-redis) -1 -3 > newFiles\n# Append the new files to the layer.\ntar -rpf temp/layer.tar --hard-dereference --sort=name --mtime=\"@$SOURCE_DATE_EPOCH\" \\\n  --owner=0 --group=0 --no-recursion --files-from newFiles\n\necho \"Adding meta...\"\n\n# If we have a parentID, add it to the json metadata.\nif [[ -n \"$parentID\" ]]; then\n  cat temp/json | jshon -s \"$parentID\" -i parent > tmpjson\n  mv tmpjson temp/json\nfi\n\n# Take the sha256 sum of the generated json and use it as the layer ID.\n# Compute the size and add it to the json under the 'Size' field.\nlayerID=$(sha256sum temp/json|cut -d ' ' -f 1)\nsize=$(stat --printf=\"%s\" temp/layer.tar)\ncat temp/json | jshon -s \"$layerID\" -i id -n $size -i Size > tmpjson\nmv tmpjson temp/json\n\n# Use the temp folder we've been working on to create a new image.\nmv temp image/$layerID\n\n# Create image json and image manifest\nimageJson=$(cat /nix/store/kxv45zmi3zrdxlgsp8fk9hsmrnbncaq8-redis-config.json | jq \". + {\\\"rootfs\\\": {\\\"diff_ids\\\": [], \\\"type\\\": \\\"layers\\\"}}\")\nmanifestJson=$(jq -n \"[{\\\"RepoTags\\\":[\\\"$imageName:$imageTag\\\"]}]\")\ncurrentID=$layerID\nwhile [[ -n \"$currentID\" ]]; do\n  layerChecksum=$(sha256sum image/$currentID/layer.tar | cut -d ' ' -f1)\n  imageJson=$(echo \"$imageJson\" | jq \".history |= [{\\\"created\\\": \\\"1970-01-01T00:00:01Z\\\"}] + .\")\n  imageJson=$(echo \"$imageJson\" | jq \".rootfs.diff_ids |= [\\\"sha256:$layerChecksum\\\"] + .\")\n  manifestJson=$(echo \"$manifestJson\" | jq \".[0].Layers |= [\\\"$currentID/layer.tar\\\"] + .\")\n\n  currentID=$(cat image/$currentID/json | (jshon -e parent -u 2>/dev/null || true))\ndone\n\nimageJsonChecksum=$(echo \"$imageJson\" | sha256sum | cut -d ' ' -f1)\necho \"$imageJson\" > \"image/$imageJsonChecksum.json\"\nmanifestJson=$(echo \"$manifestJson\" | jq \".[0].Config = \\\"$imageJsonChecksum.json\\\"\")\necho \"$manifestJson\" > image/manifest.json\n\n# Store the json under the name image/repositories.\njshon -n object \\\n  -n object -s \"$layerID\" -i \"$imageTag\" \\\n  -i \"$imageName\" > image/repositories\n\n# Make the image read-only.\nchmod -R a-w image\n\necho \"Cooking the image...\"\ntar -C image --hard-dereference --sort=name --mtime=\"@$SOURCE_DATE_EPOCH\" --owner=0 --group=0 --xform s:'./':: -c . | pigz -nT > $out\n\necho \"Finished.\"\n",
      "buildInputs": "/nix/store/j324vfkw53v306l4dx5ql4fdq5pwpw4c-jshon-20140712 /nix/store/w7chwz9xqp0vsyxl61a7hscgm5n4nybd-pigz-2.3.4 /nix/store/cb3slv3szhp46xkrczqw7mscy5mnk64l-coreutils-8.29 /nix/store/364b5gkvgrm87bh1scxm5h8shp975n0r-findutils-4.6.0 /nix/store/8cndwak3vgf313z8l0p01mnwlkxnilsb-jq-1.5",
      "builder": "/nix/store/zqh3l3lyw32q1ayb15bnvg9f24j5v2p0-bash-4.4-p12/bin/bash",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostBuild": "",
      "depsHostBuildPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "imageName": "redis",
      "imageTag": "latest",
      "layerClosure": "/nix/store/v36wjhfv55naq4qdc0sn8kza7liwn45y-runtime-deps",
      "name": "docker-image-redis.tar.gz",
      "nativeBuildInputs": "",
      "out": "/nix/store/al50if29nr4a3ivxj2b92412s0q6qria-docker-image-redis.tar.gz",
      "passAsFile": "buildCommand",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "stdenv": "/nix/store/73jpvs9j0rk37xs3r61y3aldr9sh741h-stdenv",
      "system": "x86_64-linux"
    }
  }
}
```

We can see that there is only one output for this derivation, which will be where the docker image is stored.

`inputDrvs` contains a list of derivations that the build depends on. Let's explore what the build dependencies are.

`redis-config.json` contains the configuration parameters of the image.
```json
// cat /nix/store/kxv45zmi3zrdxlgsp8fk9hsmrnbncaq8-redis-config.json | jq -C
{
  "architecture": "amd64",
  "config": {
    "Cmd": [
      "redis-server"
    ],
    "Entrypoint": [
      "/nix/store/gfhwkdm4yh7rbd2ckxs72wgv4p0994g0-entrypoint.sh"
    ],
    "Volumes": {
      "/data": {}
    },
    "WorkingDir": "/data"
  },
  "created": "1970-01-01T00:00:01Z",
  "os": "linux"
}
```

`runtime-deps` *seems to* include all the dependencies of the image:
```
# cat /nix/store/v36wjhfv55naq4qdc0sn8kza7liwn45y-runtime-deps
/nix/store/2kcrj1ksd2a14bm5sky182fv2xwfhfap-glibc-2.26-131
/nix/store/2yp7s50mvcssm44v69rmczf0pcllmmll-docker-layer-redis
/nix/store/gfhwkdm4yh7rbd2ckxs72wgv4p0994g0-entrypoint.sh
/nix/store/zqh3l3lyw32q1ayb15bnvg9f24j5v2p0-bash-4.4-p12
```

`docker-layer-redis` is a directory containing files that looks like a docker image schema v1 layer, it contains `json`, `layer.tar` and `VERSION`. If we decompress `layer.tar`, it gives us a `bin` directory with redis binaries, and an empty `data` directory. The script in the `runAsRoot` attribute has been ran during the build process.

```bash
# ls /nix/store/2yp7s50mvcssm44v69rmczf0pcllmmll-docker-layer-redis
.
├── json
├── layer.tar
└── VERSION
```

```bash
# cat /nix/store/2yp7s50mvcssm44v69rmczf0pcllmmll-docker-layer-redis/json
{
 "architecture": "amd64",
 "config": {
  "Cmd": [
   "redis-server"
  ],
  "Entrypoint": [
   "\/nix\/store\/gfhwkdm4yh7rbd2ckxs72wgv4p0994g0-entrypoint.sh"
  ],
  "Volumes": {
   "\/data": {}
  },
  "WorkingDir": "\/data"
 },
 "created": "1970-01-01T00:00:01Z",
 "os": "linux",
 "checksum": "tarsum.v1+sha256:e2c2dec0f1a17105ca47f995677911f440f7ebfc99ffc29158eb7822b31bbdd9"
}
```
And if we copy the `layer.tar` and untar it, we will get:
```
./
./bin/
./bin/redis-benchmark
./bin/redis-check-aof
./bin/redis-check-rdb
./bin/redis-cli
./bin/redis-sentinel
./bin/redis-server
./data/
```

We can see that `runAsRoot` has already been ran to build docker-layer-redis. This is interesting because usually any file structures added at image build time are the last layers. For example the first command in Dockerfile is usually the FROM command, which takes in an image, all following commands add layers on top of that image. This means that **`docker-layer-redis` likely represents the last applied layer in the resulting image**.

Now if we build the ouput using `nix-store -r /nix/store/3w0rb8j1nfxi1bbjs7191gpv2jn6rz7k-docker-image-redis.tar.gz.drv`, which will create a file `result` that symlinks to the outpath. We will do `docker load < result` and see what the image looks like:

```bash
# docker load < result
# docker export redis:latest | tar -x
# tree .
.
├── 3f31daf1e4f1283976271132438d6c8b45d36864f23d4a39918dad4ffdd6b867.json
├── c26d1c9798b940bf17e38aabc09f7cb5476fcbf4dfc57cb2a1ec510bc917f2ab
│   ├── json
│   ├── layer.tar
│   └── VERSION
└── manifest.json
```

We can see that the file only consists of one layer (each directory represents a layer, it can also bee seen in `manifest.json`.). This is strange because a redis image already has more than one layers when pulled from the docker registry. We can compare this with an actual redis image pulled from docker.

```sh
# docker pull redis:latest
# docker save redis:latest | tar -x
# tree
.
├── 0bfb03aaab6d802b584c2f66f5c6edee4ea0c3e1a19e3617409cc7c85e8a5f74
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 29a40fda72ca55572773543ed228c49f60353658170b574d12d9526a0793e987
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 4c02b48c2033e481c8746c581e04192270d87abc72bb86690097101104c3a88c
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 4e8db158f18dc71307f95260e532df39a9b604b51d4e697468e82845c50cfe28.json
├── 6b41dc328966eec8d4991aa9c86462a93fb0424e42d8949ff1a01cb5d22fde78
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 73859f730774ca870790ab5409a307bff945663ac7c410a6317e4c43ff503dfb
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── f8b20f21fa1780804ed76985260d831967cc15a3fb09007b9d3d5f261d6582f5
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── manifest.json
└── repositories
```

This shows that **Nix's dockertools flatten images into one layer only**.
