# Notes: LXC and Libcontainer
tag: research, docker, container


## Terminologies
- **Pages** When a process uses some memory, the CPU is marking the RAM as used
by that process. For efficiency, the CPU allocates RAM by chunks of 4K bytes (it's the default value on many platforms). These chunks are called pages.
- **Hugepages** MMU has to remember which pages belong to which process, and
the more pages you have, the more time it takes to find where the memory is mapped.
Hence most current CPU architectures support bigger pages, so called "Huge pages".
- **NUMA System** Non-uniform memory access is a computer memory design used in multiprocessing,
where the memory access time depends on the memory location relative to the processor.
Under NUMA, a processor can access its own local memory faster than non-local memory.


## LXC
LXC is a userspace interface for the linux containment features.
Trough a powerful API and simple tools, it lets linux users easily create and manage system or application containers.

## Libcontainer
- Linux namespaces (sysfs)
- control groups
- capabilities
- AppArmor
- Security profiles
- Network interfaces
- Firewalling rules

### Control groups
Limit resources and permission management on processes.
- Each subsystem has a hierarchy
  (separate hierarchies for CPU, memory, block I/O.)
- Hierarchies are independent
- Each process is in a node in each hierarchy
- Each hierarchy starts with 1 node (the root)
- Initially, all processes start at the root node
- Each node = group of processes sharing the same resources

#### Memory cgroup
##### Accounting
- Keep track of pages used by each group
  - File (read/write/mmap from block devices)
  - Anonymous (stack, heap, anonymous mmap)
  - Active (recently accessed)
  - Inactive (candidate for eviction)

##### Limits
- Each group can have its own limits
  - limits are optional
  - two kinds of limits: soft and hard limits
- Soft limits are not enforced
  - They influence reclaim under memory pressure
- Hard limits will trigger a per-group OOM killer
- over-provisioning
- Limits can be set for different kinds of memory
  - Physical Memory
  - Kernel memory
  - Total memory (physical for swap)

##### Avoiding OOM killer
- Do you like when the kernel terminates random processes because something unrelated ate all the memory in the system?
- Setup oom-notifier
- Then, when the hard limit is exceeded:
  1. Freeze all processes in the groups
  1. Notify user space (instead of going rampage)
  1. We can kill processes, raise limits, migrate containers
  1. When we;re in the clear again, unfreeze the group

##### Tricky Details
- Each time the kernel gives a page to a process, or takes it away, it updates the counters
- This adds some overhead
- This cannot be enabled/disabled per process
- When multiple groups use the same page, only the first one is charged.

##### HugeTLB cgroup
- Controls the amount of huge pages usable by a process

#### CPU cgroup
- Keeps track of user/system CPU time
- Keep track of usage per CPU
- Allows to set weights
- Can't set CPU limits

#### CPUset cgroup
- Pin groups to specific CPU(s)
- Reserve CPUs for specific apps
- Avoid processes bouncing between CPUs
- Also relevant for NUMA systems
- Provides extra dials and knobs (per zone memory pressure, process migration costs).

#### Blkio cgroup
- Keeps track of I/Os for each group
  - per block device
  - read vs write
  - sync vs aync
- Set throttle (limits) for each group
  - per block device
  - read vs write
  - sync vs aync
- Set relative weights for each group
- Note: Most writes go through the page cache.

#### NET_CLS and NET_PRIO cgroup
- Automatically set traffic class or priority, for traffic generated by processes in the group
- Only works for egress traffic
- NET_CLS will assign traffic to a class
- NET_PRIO will assign traffic to a priority

## Libct (Odin)
C/C++, Python

## Sources
[Hugepages](https://wiki.debian.org/Hugepages)
[DockerCon: cgroups, namespaces and beyond](https://www.youtube.com/watch?v=sK5i-N34im8)
